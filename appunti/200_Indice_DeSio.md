# De Sio Cesari - Manuale di Java

_manuali consigliati in italiano_

## Modulo 1 - Introduzione a Java
* 1.1 Introduzione a Java
* 1.1.1 Cosa è Java
* 1.1.2 Breve storia di Java
* 1.1.3 Perché Java (why)
* 1.1.4 Caratteristiche di Java
* 1.2 Situazione attuale
* 1.3 Ambiente di sviluppo
* 1.3.1 Ambienti di sviluppo più complessi
* 1.4 Struttura del JDK
* 1.4.1 Guida dello sviluppatore passo dopo passo
* 1.5 Primo approccio al codice
* 1.6 Analisi del programma “HelloWorld”
* 1.7 Compilazione ed esecuzione del programma HelloWorld
* 1.8 Possibili problemi in fase di compilazione ed esecuzione
* 1.8.1 Possibili messaggi di errore in fase di compilazione
* 1.8.2 Possibili messaggi relativi alla fase di interpretazione

## Modulo 2 - Componenti fondamentali di un programma Java
* 2.1 Componenti fondamentali di un programma Java
* 2.1.1 Convenzione per la programmazione Java
* 2.2 Le basi della programmazione object oriented: classi e oggetti
* 2.2.1 Osservazione importante sulla classe Punto
* 2.2.2 Osservazione importante sulla classe Principale
* 2.2.3 Un’altra osservazione importante
* 2.3 I metodi in Java
* 2.3.1 Dichiarazione di un metodo
* 2.3.2 Chiamata (o invocazione) di un metodo
* 2.3.3 Varargs
* 2.4 Le variabili in Java
* 2.4.1 Dichiarazione di una variabile:
* 2.4.2 Variabili d’istanza
* 2.4.3 Variabili locali
* 2.4.4 Parametri formali
* 2.5 I metodi costruttori
* 2.5.1 Caratteristiche di un costruttore
* 2.5.2 Costruttore di default
* 2.5.3 Package

## Modulo 3 - Identificatori, tipi di dati ed array
* 3.1 Stile di codifica
* 3.1.1 Schema Libero
* 3.1.2 Case sensitive
* 3.1.3 Commenti
* 3.1.4 Regole per gli identificatori
* 3.1.5 Regole facoltative per gli identificatori e convenzioni per i nomi
* 3.2 Tipi di dati primitivi
* 3.2.1 Tipi di dati interi, casting e promotion
* 3.2.2 Tipi di dati a virgola mobile, casting e promotion
* 3.2.3 Underscore in tipi di dati numerici
* 3.2.4 Tipo di dato logico-booleano
* 3.2.5 Tipo di dato primitivo letterale
* 3.3 Tipi di dati non primitivi: reference
* 3.3.1 Passaggio di parametri per valore
* 3.3.2 Inizializzazione delle variabili d’istanza
* 3.4 Introduzione alla libreria standard
* 3.4.1 Il comando import
* 3.4.2 La classe String
* 3.4.3 La documentazione della libreria standard di Java
* 3.4.4 Lo strumento javadoc
* 3.4.5 Gli array in Java
* 3.4.6 Dichiarazione
* 3.4.7 Creazione
* 3.4.8 Inizializzazione
* 3.4.9 Array multidimensionali
* 3.4.10 Limiti degli array

## Modulo 4 - Operatori e gestione del flusso di esecuzione
* 4.1 Operatori di base
* 4.1.1 Operatore di assegnazione
* 4.1.2 Operatori aritmetici
* 4.1.3 Operatori (unari) di pre e post-incremento (e decremento)
* 4.1.4 Operatori bitwise
* 4.1.5 Operatori relazionali o di confronto
* 4.1.6 Operatori logico-booleani
* 4.1.7 Concatenazione di stringhe con +
* 4.1.8 Priorità degli operatori
* 4.2 Gestione del flusso di esecuzione
* 4.3 Costrutti di programmazione semplici
* 4.3.1 Il costrutto if
* 4.3.2 L’operatore ternario
* 4.3.3 Il costrutto while
* 4.4 Costrutti di programmazione avanzati
* 4.4.1 Il costrutto for
* 4.4.2 Il costrutto do
* 4.4.3 Ciclo for migliorato
* 4.4.4 Il costrutto switch
* 4.4.5 Due importanti parole chiave: break e continue

## Modulo 5 - Programmazione ad oggetti utilizzando Java: incapsulamento ed ereditarietà
* 5.1 Breve storia della programmazione ad oggetti
* 5.2 I paradigmi della programmazione ad oggetti
* 5.2.1 Astrazione e riuso
* 5.3 Incapsulamento
* 5.3.1 Prima osservazione sull’incapsulamento
* 5.3.2 Seconda osservazione sull’incapsulamento
* 5.3.3 Il reference this
* 5.3.4 Due stili di programmazione a confronto
* 5.4 Quando utilizzare l’incapsulamento
* 5.5 Ereditarietà
* 5.5.1 La parola chiave extends
* 5.5.2 Ereditarietà multipla e interfacce
* 5.5.3 La classe Object
* 5.6 Quando utilizzare l’ereditarietà
* 5.6.1 La relazione “is a”
* 5.6.2 Generalizzazione e specializzazione
* 5.6.3 Rapporto ereditarietà-incapsulamento
* 5.6.4 Modificatore protected
* 5.6.5 Conclusioni

## Modulo 6 - Programmazione ad oggetti utilizzando Java: polimorfismo
* 6.1 Polimorfismo
* 6.1.1 Convenzione per i reference
* 6.2 Polimorfismo per metodi
* 6.2.1 Overload
* 6.2.2 Varargs
* 6.2.3 Override
* 6.2.4 Override e classe Object: metodi toString(), clone(), equals() e hashcode()
* 6.2.5 Annotazione sull’override
* 6.3 Polimorfismo per dati
* 6.3.1 Parametri polimorfi
* 6.3.2 Collezioni eterogenee
* 6.3.3 Casting di oggetti
* 6.3.4 Invocazione virtuale dei metodi
* 6.3.5 Esempio d’utilizzo del polimorfismo
* 6.3.6 Conclusioni

## Modulo 7 - Un esempio guidato alla programmazione ad oggetti
* 7.1 Perché questo modulo
* 7.2 Esercizio 7.a
* 7.3 Risoluzione dell’esercizio 7.a
* 7.3.1 Passo 1
* 7.3.2 Passo 2
* 7.3.3 Passo 3
* 7.3.4 Passo 4
* 7.3.5 Passo 5
* 7.4 Introduzione al test e al debug
* 7.4.1 Unit Testing in teoria
* 7.4.2 Unit Test in pratica con JUnit
* 7.4.3 Debug

## Modulo 8 - Caratteristiche avanzate del linguaggio
* 8.1 Costruttori e polimorfismo
* 8.1.1 Overload dei costruttori
* 8.1.2 Override dei costruttori
* 8.2 Costruttori ed ereditarietà
* 8.3 super: un “super reference”
* 8.3.1 super e i costruttori
* 8.4 Altri componenti di un’applicazione Java: classi innestate e anonime
* 8.4.1 Classi innestate: introduzione e storia
* 8.4.2 Classe innestata: definizione
* 8.4.3 Classi innestate: proprietà
* 8.4.4 Classi anonime: definizione

## Modulo 9 - Modificatori, package e interfacce
* 9.1 Modificatori fondamentali
* 9.2 Modificatori d’accesso
* 9.3 Gestione dei package
* 9.3.1 Classpath
* 9.3.2 File JAR
* 9.3.3 Classpath e file JAR
* 9.3.4 Gestione “a mano”
* 9.4 Il modificatore final
* 9.5 Il modificatore static
* 9.5.1 Metodi statici
* 9.5.2 Variabili statiche (di classe)
* 9.5.3 Inizializzatori statici e inizializzatori d’istanza
* 9.5.4 Static import9.6 Il modificatore abstract
* 9.6.1 Metodi astratti
* 9.6.2 Classi astratte
* 9.7 Interfacce
* 9.7.1 Regole di conversione dei tipi
* 9.7.2 Ereditarietà multipla
* 9.7.3 Differenze tra interfacce e classi astratte
* 9.8 Tipi enumerazioni
* 9.8.1 Ereditarietà ed enum
* 9.8.2 Costruttori ed enum
* 9.8.3 Quando utilizzare un’enum
* 9.9 Modificatori di uso raro: native, volatile e strictfp
* 9.9.1 Il modificatore strictfp
* 9.9.2 Il modificatore native
* 9.9.3 Il modificatore volatile

## Modulo 10 - Eccezioni e asserzioni
* 10.1 Eccezioni, errori e asserzioni
* 10.2 Gerarchie e categorizzazioni
* 10.3 Meccanismo per la gestione delle eccezioni
* 10.4 Try with resources
* 10.5 Eccezioni personalizzate e propagazione dell’eccezione
* 10.5.1 Precisazione sull’override
* 10.6 Introduzione alle asserzioni
* 10.6.1 Progettazione per contratto
* 10.6.2 Uso delle asserzioni
* 10.6.3 Note per la compilazione di programmi che utilizzano la parola assert
* 10.6.4 Note per l’esecuzione di programmi che utilizzano la parola assert
* 10.6.5 Quando usare le asserzioni
* 10.6.6 Conclusioni

## Modulo 11 - Gestione dei thread
* 11.1 Introduzione ai thread
* 11.1.1 Definizione provvisoria di thread
* 11.1.2 Cosa significa “multithreading”
* 11.2 La classe Thread e la dimensione temporale
* 11.2.1 Analisi di ThreadExists
* 11.2.2 L’interfaccia Runnable e la creazione dei thread
* 11.2.3 Analisi di ThreadCreation
* 11.2.4 La classe Thread e la creazione dei thread
* 11.3 Priorità, scheduler e sistemi operativi
* 11.3.1 Analisi di ThreadRace
* 11.3.2 Comportamento Windows (time slicing o round-robin scheduling)
* 11.3.3 Comportamento Unix (preemptive scheduling)
* 11.4 Thread e sincronizzazione
* 11.4.1 Analisi di Synch
* 11.4.2 Monitor e Lock
* 11.5 La comunicazione fra thread
* 11.5.1 Analisi di IdealEconomy
* 11.6 Concorrenza

## Modulo 12 - Le librerie alla base del linguaggio: java.lang e java.util
* 12.1 Package java.util
* 12.1.1 Framework Collections
* 12.1.2 Implementazioni di Map e SortedMap
* 12.1.3 Implementazioni di Set e SortedSet
* 12.1.4 Implementazioni di List
* 12.1.5 Le interfacce Queue, BlockingQueue e ConcurrentMap
* 12.1.6 Algoritmi e utilità
* 12.1.7 Collection personalizzate
* 12.1.8 Collections e Generics
* 12.1.9 Le classi Properties e Preferences
* 12.1.10 Classe Locale e internazionalizzazione
* 12.1.11 La classe ResourceBundle
* 12.1.12 Date, orari e valute
* 12.1.13 La classe StringTokenizer
* 12.1.14 Espressioni regolari
* 12.2 Introduzione al package java.lang
* 12.2.1 La classe String
* 12.2.2 La classe System
* 12.2.3 La classe Runtime
* 12.2.4 La classe Class e Reflection
* 12.2.5 Le classi wrapper
* 12.2.6 La classe Math

## Modulo 13 - Comunicare con Java: input, output e networking
* 13.1 Introduzione all’input-output
* 13.2 Pattern Decorator
* 13.2.1 Descrizione del pattern
* 13.3 Descrizione del package
* 13.3.1 I Character Stream
* 13.3.2 I Byte Stream
* 13.3.3 Le superinterfacce principali
* 13.3.4 Chiusura degli stream
* 13.4 Input e output “classici”
* 13.4.1 Lettura di input da tastiera
* 13.4.2 Gestione dei file
* 13.4.3 Serializzazione di oggetti
* 13.5 NIO 2.0 (New Input Output aggiornato a Java 7)
* 13.5.1 L’interfaccia Path
* 13.5.2 La classe Files
* 13.6 Introduzione al networking

## Modulo 14 - Java e la gestione dei dati: supporto a SQL e XML
* 14.1 Introduzione a JDBC
* 14.2 Le basi di JDBC
* 14.2.1 Implementazione del vendor (Driver JDBC)
* 14.2.2 Implementazione dello sviluppatore (Applicazione JDBC)
* 14.2.3 Analisi dell’esempio JDBCApp
* 14.3 Altre caratteristiche di JDBC
* 14.3.1 Indipendenza dal database
* 14.3.2 Altre operazioni JDBC (CRUD)
* 14.3.3 Statement parametrizzati
* 14.3.4 Stored procedure
* 14.3.5 Mappature Java – SQL
* 14.3.6 Transazioni
* 14.3.7 Evoluzione di JDBC
* 14.3.8 JDBC 2.0
* 14.3.9 JDBC 3.0
* 14.3.10 JDBC 4.0 e 4.1
* 14.4 Supporto a XML: JAXP
* 14.4.1 Creare un documento DOM a partire da un file XML
* 14.4.2 Recuperare la lista dei nodi da un documento DOM
* 14.4.3 Recuperare particolari nodi
* 14.4.4 XPATH
* 14.4.5 Modifica di un documento XML
* 14.4.6 Analisi di un documento tramite parsing SAX
* 14.4.7 Trasformazioni XSLT

## Modulo 15 - Interfacce grafiche (GUI) con AWT, Applet e Swing
* 15.1 Introduzione alla Graphical User Interface (GUI)
* 15.2 Introduzione ad Abstract Window Toolkit (AWT)
* 15.2.1 Struttura della libreria AWT ed esempi
* 15.3 Creazione di interfacce complesse con i layout manager
* 15.3.1 Il FlowLayout
* 15.3.2 Il BorderLayout
* 15.3.3 Il GridLayout
* 15.3.4 Creazione di interfacce grafiche complesse
* 15.3.5 Il GridBagLayout
* 15.3.6 Il CardLayout
* 15.4 Gestione degli eventi
* 15.4.1 Observer e Listener
* 15.4.2 Classi innestate e classi anonime
* 15.4.3 Altri tipi di eventi
* 15.5 La classe Applet
* 15.6 Introduzione a Swing
* 15.6.1 Swing vs AWT
* 15.6.2 Le ultime novità per Swing
* 15.6.3 File JAR eseguibile

## Modulo 16 - Autoboxing, Autounboxing e Generics
* 16.1 Introduzione a Tiger
* 16.1.1 Perché Java 5?
* 16.2 Autoboxing e Autounboxing
* 16.2.1 Impatto su Java
Assegnazione di un valore null al tipo wrapperCostrutti del linguaggio e operatori relazionali
Overload
* 16.3 Generics
* 16.3.1 Dietro le quinte
* 16.3.2 Tipi primitivi
* 16.3.3 Interfaccia Iterator
* 16.3.4 Interfaccia Map
* 16.3.5 Ereditarietà dei Generics
* 16.3.6 Wildcard
* 16.3.7 Creare propri tipi generici
* 16.3.8 Java 7 e la deduzione automatica del tipo
* 16.3.9 Impatto su Java
Compilazione
Cambiamento di mentalità
Parametri covarianti
Casting automatico di reference al loro tipo “intersezione” nelle operazioni condizionali

## Modulo 17 - Ciclo for migliorato ed enumerazioni

* 17.1 Ciclo for migliorato
* 17.1.1 Limiti del ciclo for migliorato
* 17.1.2 Implementazione di un tipo Iterable
* 17.1.3 Impatto su Java
* 17.2 Tipi Enumerazioni
* 17.2.1 Perché usare le enumerazioni
* 17.2.2 Proprietà delle enumerazioni
* 17.2.3 Caratteristiche avanzate di un’enumerazione

## Modulo 18 - Varargs e static import
* 18.1 Varargs
* 18.1.1 Approfondimento sui varargs
* 18.1.2 Impatto su Java
Flessibilità con il polimorfismo
Override
Formattazioni di output
* 18.2 Static import
* 18.2.1 Un parere personale
* 18.2.2 Impatto su Java
Reference ambigui
Shadowing

## Modulo 19 - Annotazioni (metadati)
* 19.1 Introduzione al modulo
* 19.2 Definizione di annotazione (metadato)
* 19.2.1 Primo esempio
* 19.2.2 Tipologie di annotazioni e sintassi
* 19.3 Annotare annotazioni (metaannotazioni)19.3.1 Target
* 19.3.2 Retention
* 19.3.3 Documented
* 19.3.4 Inherited
* 19.3.5 Override
* 19.3.6 Deprecated
* 19.3.7 SuppressWarnings
* 19.3.8 Impatto su Java
* 19.5 Ed ora?
